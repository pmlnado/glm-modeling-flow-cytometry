---
title: "IMPAcTB Day 14 testing data and stats"
author: "Pablo Maldonado"
date: "6/8/2023"
output:
  html_document: default
  word_document: default
  pdf_document: default
editor_options:
  chunk_output_type: inline
---

```{r global options}
knitr::opts_chunk$set(echo = TRUE, error = FALSE, message = FALSE, warning = FALSE)

```

## Loading packages

```{r message=FALSE, warning=FALSE, include=FALSE}
library(jtools)
library(readxl)
library(ggplot2)
library(RColorBrewer)
library(dplyr)
library(tidyverse)
library(scales)
library(stringr)
library(tidyr)
library(knitr)
library(forcats)
library(broom)
library(ggfortify)
library(stats)
library(ggpubr)
library(grDevices)
library(rstatix)
library(writexl)
library(purrr)
library(kableExtra)
library(ggbeeswarm)
library(multcomp)
library(DescTools)
library(car)
library(exactRankTests)
library(readr)
library(ggeffects)
library(GGally)
library(gridExtra)
library(emmeans)
#mm7qNhXs8FN4CFS
```

MULTI CSV SHEETS MALE FEMALE
```{r echo=TRUE, message=FALSE, warning=FALSE}
# Read in all CSV files
files <- list.files(path = "/Volumes/cvmbs/RSTOR-HenaO_lab/Pablo/IMPAcTB-Flow-pipeline/Tcell_lg_csv", pattern = "*.csv", full.names = TRUE)

dfs <- lapply(files, function(file) {
  # Read the CSV file and clean up column names
  df <- read_csv(file)
    df <- df %>%
    rename("Sample" = colnames(.)[1]) %>%
    dplyr::select(Sample, contains("Count")) %>%
    rename_all(funs(str_replace(., "\\|.+", ""))) %>%
    rename_all(~ str_remove(., "Leukocytes/Single Cells/")) %>%
    rename_all(~ str_remove(., "Leukocytes/")) %>%
    rename_all(~ str_remove(., "LIVE/")) %>%
    # mutate(Sample = str_replace_all(Sample, "\\b[A-Za-z][0-9]+\\b", "")) %>%
    rename_all(funs(str_replace_all(., ",", ""))) %>%
    rename_all(funs(str_replace_all(., "/", " "))) %>%
    rename_all(funs(str_replace_all(., "\\\\", " ")))  %>%
    rename_all(~ stringr::str_replace_all(., "Q\\d+\\:", "")) %>%
    rename("cells in sample" := matches("Count")) %>%
    rename("leukocytes" := matches("Leukocytes")) %>%
    rename("live leukocytes" := matches("LIVE")) %>%
    rename("single cells" := matches("Single Cells")) %>%
  # Removing logical vectors, not sure why its adding these
  dplyr::select(where(~ !any(is.logical(.)) | is.numeric(.))) %>%
  # Remove last two rows of SD and Mean
  slice(1:(n() - 2))
  # Extract the sex from the file name
  sex <- ifelse(grepl("female", file), "female", "male")
  df <- df %>% mutate(sex = sex)
  # Move the sex column to the second position
  df <- df %>% relocate(sex, .after = 1)
  # Extract the day from the file name
  day <- str_extract(file, "(?<=Day\\s)\\d+")
  df <- df %>% mutate(day = as.character(day))
  # Move the day column to the third position
  df <- df %>% relocate(day, .after = 2)
  
  return(df)
})

# Combine all data frames into one dataframe
Df1 <- bind_rows(dfs)
Df1

#str(dfs)
#tail(Df1)

# Check for NA values in Df1
#na_counts <- colSums(is.na(Df1))

# Print the column names with NA counts
#print(na_counts)
Df1

# barbering, fighting, UD, injury, new cage, euthanize, illness
```

## MAKING DATA TIDY
```{r echo=TRUE, message=FALSE, warning=FALSE}
tidy_Df1 <- pivot_longer(data = Df1, cols =  starts_with("CD3"), names_to = "cell_types", values_to = "cell type count")

tidy_Df1 <- tidy_Df1 %>%
  separate(col = "Sample", into = c("group", "mouse_ID"), sep = "_") %>%
  mutate(mouse_ID = str_replace(mouse_ID, ".fcs", ""))

# Trim extra spaces
tidy_Df1$cell_types <- str_replace_all(tidy_Df1$cell_types, "\\s+", " ")
tidy_Df1$cell_types <- str_trim(tidy_Df1$cell_types)
tidy_Df1$group <- trimws(tidy_Df1$group)

# Fix Group Column
tidy_Df1 <- tidy_Df1 %>%
  mutate(group = gsub("^[A-Za-z]\\d{1,2}\\s", "", group))
tidy_Df1$group <- str_replace_all(tidy_Df1$group, "-", " ")

tidy_Df1 
```

## Insert trials and successes (cell counts and parent populations)
```{r echo=TRUE, message=FALSE, warning=FALSE}
# Filter CD3+ CD4+, CD3+ CD4+ CD62L- CD44+ to find trials and successes
tidy_Df1$cell_types [3]
t_cell_activation <- tidy_Df1 %>%
  dplyr::filter(cell_types == "CD3+ CD4+" | cell_types == "CD3+ CD4+ CD62L- CD44+") 

t_cell_activation <- t_cell_activation %>%
  pivot_wider(names_from = cell_types, values_from = `cell type count`) %>%
  rename(trials = "CD3+ CD4+", successes = "CD3+ CD4+ CD62L- CD44+") %>%
  mutate(failures = trials - successes) %>%
  dplyr::select(-`cells in sample`, -leukocytes, -`single cells`)

t_cell_activation

# Recode the condition and group names
t_cell_activation$group <- factor(t_cell_activation$group, levels = c("Saline", "BCG", "ID93", "BCG+ID93"))

t_cell_activation <- t_cell_activation %>%
  mutate(group = ifelse(group == "ID93", "ID93+GLA-SE",
                       ifelse(group == "BCG+ID93", "BCG-ID93+GLA-SE",
                              ifelse(group == "Saline", "Saline",
                                     ifelse(group == "BCG", "BCG", group)))))



t_cell_activationPLOT <- t_cell_activation
t_cell_activationPLOT <- t_cell_activationPLOT %>%
  mutate(proportion_of_activated_tcells = (successes/trials*100)) 

```
#Better than BCG?
#does sex matter?
#key immune populations?

# Set reference group
```{r echo=TRUE, message=FALSE, warning=FALSE}
# Convert 'result' into a factor data type.
t_cell_activation$successes <- as.factor(t_cell_activation$successes)
# Convert 'group' into a factor data type.
t_cell_activation$group <- factor(t_cell_activation$group)
# Convert 'day' into a factor data type.
t_cell_activation$day <- as.factor(t_cell_activation$day)
t_cell_activation$failures <- as.factor(t_cell_activation$failures)
t_cell_activation$sex <- as.factor(t_cell_activation$sex)

# Reorder groups for visuals
t_cell_activation <- t_cell_activation %>%
  mutate(group = fct_relevel(group, "Saline", "BCG", "ID93+GLA-SE", "BCG-ID93+GLA-SE"))
t_cell_activation$group <- relevel(t_cell_activation$group, ref = "Saline")
```


## Detecting outliers based on group and sex
```{r eval=FALSE, include=FALSE}
# # Create a sample data frame
# 
# outliersubset_data <- t_cell_activationPLOT
# 
# 
# detect_outliers_within_group_sex <- function(dataframe, column, group_column, sex_column) {
#   
#     if (!(column %in% colnames(dataframe))) {
#     stop("Column not found in the dataframe")
#   }
#   
#   if (!(group_column %in% colnames(dataframe))) {
#     stop("Grouping column not found in the dataframe")
#   }
#   
#   if (!is.numeric(dataframe[[column]])) {
#     stop("Column must contain numeric data")
#   }
#   
# # Group by the "group" and "sex" columns
#   grouped_data <- dataframe %>%
#     group_by(!!sym(group_column), !!sym(sex_column)) %>%
#     summarise(
#       Quantile1 = quantile(!!sym(column), probs = 0.25),
#       Quantile3 = quantile(!!sym(column), probs = 0.75),
#       IQR = Quantile3 - Quantile1,
#       .groups = "drop"
#     )
#   
#   # Left join the grouped data with the original dataframe
#   sample_dataIQR <- dataframe %>%
#     left_join(grouped_data, by = c(group_column, sex_column))
#   
#   # Filter for outliers
#   outliers <- sample_dataIQR %>%
#     group_by(!!sym(group_column), !!sym(sex_column)) %>%
#     filter(!!sym(column) > (Quantile3 + IQR * 1.5) | !!sym(column) < (Quantile1 - IQR * 1.5))
#   
#   if (nrow(outliers) > 0) {
#     # Return the rows containing outliers in the specified column
#     return(outliers)
#   } else {
#     message("No outliers found in the specified column.")
#     return(NULL)
#   }
# }
# 
# 
# # Usage
# detect_outliers_within_group_sex(outliersubset_data, "proportion_of_activated_tcells", "group", "sex")
```


## Detecting outliers based on group ONLY
```{r eval=FALSE, include=FALSE}
# 
# detect_outliers_within_group <- function(dataframe, column, group_column) {
#   
#     if (!(column %in% colnames(dataframe))) {
#     stop("Column not found in the dataframe")
#   }
#   
#   if (!(group_column %in% colnames(dataframe))) {
#     stop("Grouping column not found in the dataframe")
#   }
#   
#   if (!is.numeric(dataframe[[column]])) {
#     stop("Column must contain numeric data")
#   }
#   
# # Group by the "group" and "sex" columns
#   grouped_data <- dataframe %>%
#     group_by(!!sym(group_column)) %>%
#     summarise(
#       Quantile1 = quantile(!!sym(column), probs = 0.25),
#       Quantile3 = quantile(!!sym(column), probs = 0.75),
#       IQR = Quantile3 - Quantile1)
#   
#   # Left join the grouped data with the original dataframe
#   sample_dataIQR <- dataframe %>%
#     left_join(grouped_data, by = group_column)
#   
#   # Filter for outliers
#   outliers <- sample_dataIQR %>%
#     group_by(!!sym(group_column)) %>%
#     filter(!!sym(column) > (Quantile3 + IQR * 1.5) | !!sym(column) < (Quantile1 - IQR * 1.5))
#   
#   if (nrow(outliers) > 0) {
#     # Return the rows containing outliers in the specified column
#     return(outliers)
#   } else {
#     message("No outliers found in the specified column.")
#     return(NULL)
#   }
# }
# 
# detect_outliers_within_group(outliersubset_data, "proportion_of_activated_tcells", "group")



# Revome outliers OPTIONAL
# 
# t_cell_activation_outliers <- outliersubset_data %>%
#   filter(!(group == "Saline" & mouse_ID == "2" & sex == "female" & day == "14") &
#          !(group == "BCG" & mouse_ID == "1" & sex == "female" & day == "14"))
```

$$
log(p / (1 - p)) = β₀ + β₁*Saline + β₂*ID93 + β₃*BCG+ID93 + β₄*day56 + β₅*sexmale + β₆*(Saline * day56) + β₇*(ID93 * day56) + β₈*(BCG+ID93 * day56) + β₉*(Saline * sexmale) + β₁₀*(ID93 * sexmale) + β₁₁*(BCG+ID93 * sexmale)
$$
$$
log(p / (1 - p)) = β₀ + β₁*X1 + β₂*X2 + β₃*X3 + β₄*X4 + β₅*X5 + β₆*(X1 * X4) + β₇*(X2 * X4) + β₈*(X3 * X4) + β₉*( X1 * X5) + β₁₀*(X2 * X5) + β₁₁*(X3 * X5)
$$

## GLM modeling for: group * day + sex | group * day * sex | group * day
```{r echo=TRUE}

l_mod1 <- glm(cbind(successes, failures) ~ group * day + sex, 
              family = quasibinomial(link = "logit"), data = t_cell_activation)
summary(l_mod1)
# after adjusting for sex


# # log(p / (1 - p)) = β₀ + β₁*Saline + β₂*ID93 + β₃*BCG93 + β₄*Male + β₅*Day56 + β₆*(Saline * Male) + β₇*(ID93 * Male) + β₈*(BCG93 * Male) + β₉*(Saline * Day56) + β₁₀*(ID93 * Day56) + β₁₁*(BCG93 * Day56) + β₁₂*(Saline * Male * Day56) + β₁₃*(ID93 * Male * Day56) + β₁₄*(BCG93 * Male * Day56)
# l_mod2 <- glm(cbind(successes, failures) ~ group * day * sex,
#               family = quasibinomial(link = "logit"), data = t_cell_activation)
# summary(l_mod2)


# #log(p / (1 - p)) =  β₁*Saline + β₂*ID93 + β₃*BCG93 + β₄*Day56 + β₅*(Saline * Day56) + β₆*(ID93 * Day56) + β₇*(BCG93 * Day56)
# l_mod3 <- glm(cbind(successes, failures) ~ group * day,
#               family = quasibinomial(link = "logit"), data = t_cell_activation)
# summary(l_mod3)

```

## Cook's D (Cook's distance) is a statistical measure used in regression analysis to quantify the influence of individual data points (observations) on the model's parameter estimates. It helps identify observations that, if removed from the dataset, would lead to significant changes in the estimated coefficients or model predictions. In essence, Cook's D indicates how much a specific data point affects the overall regression model.
```{r echo=TRUE}
#Calculate Cook's distance
cooksd <- cooks.distance(l_mod1)

# Define a threshold for influential points (e.g., 4/n)
threshold <- 4 / length(cooksd)

# Identify influential observations (those with Cook's distance above the threshold)
influential <- cooksd > threshold

# Create a scatterplot to visualize outliers and influential points
plot(cooksd, pch = 19, cex = 1, main = "Cook's Distance Plot")
abline(h = threshold, col = "red") # Add a horizontal line at the threshold

# Color the points to differentiate between outliers and influential points
points(which(influential), cooksd[influential], col = "red", pch = 19)
points(which(!influential), cooksd[!influential], col = "blue", pch = 19)

# Add legend
legend("topright", legend = c("Influential", "Not Influential"),
       col = c("red", "blue"), pch = 19)

# Identify the indices of influential points
influential_indices <- which(cooksd > threshold)

t_cell_activation[influential_indices, ]

t_cell_activation <- t_cell_activation[-influential_indices, ]
t_cell_activationPLOT <- t_cell_activationPLOT[-influential_indices, ]

l_mod1 <- glm(cbind(successes, failures) ~ group * day + sex,
              family = quasibinomial(link = "logit"), data = t_cell_activation)

summary(l_mod1)


```

## Drop-in-deviance test to compare models

# CAN WE LEAVE OUT SEX BASED ON SIGNIFICANCE?
```{r echo=TRUE}
# drop_in_dev1 <- anova(l_mod1, l_mod2, test = "Chisq")
#drop_in_dev2 <- anova(l_mod1, l_mod3, test = "Chisq")
# drop_in_dev3 <- anova(l_mod2, l_mod3, test = "Chisq")
# 
# 
# drop_in_dev1 
#drop_in_dev2 
# drop_in_dev3 

# The preferred model for this analysis is cbind(successes, failures) ~ group * day + sex because it strikes a good balance between model performance and interpretability. It offers clear insights into the effects of group, day, and sex on the response variables. In contrast, the more complex model cbind(successes, failures) ~ group * day * sex does not significantly improve the model's explanatory power, raising concerns about overfitting and hindering the interpretation of results. Choosing the simpler model ensures that we have a practical and interpretable model for making informed decisions based on the data while avoiding unnecessary complexity that can complicate findings.The Analysis of Deviance Table does indicate a significant difference between the two models, Model 1 (cbind(successes, failures) ~ group * day + sex) and Model 2 (cbind(successes, failures) ~ group * day * sex). This suggests that Model 2 provides a statistically significant improvement in explaining the variance in the response variables compared to Model 1. However, statistical significance does not necessarily imply practical significance or better model performance. Model 2 introduces more complexity by including additional interaction terms, and it may be prone to overfitting, which can result in a less interpretable/generalizable model. Therefore, while there is evidence of a difference between the models Model 1 remains a reasonable choice as it provides a good balance between interpretability and model performance.
```

## Model diagnostics 
## Plots involving the residuals are used for assessing the validity of the model assumptions for GLMs.
```{r echo=TRUE}
# Create a residual vs fitted plot
residuals <- residuals(l_mod1)
fitted_values <- fitted(l_mod1)

# Create the residuals vs. fitted plot
plot(fitted_values, residuals, main = "Residuals vs. Fitted", 
     xlab = "Fitted Values", ylab = "Residuals")

# Add a horizontal reference line at y = 0 (optional)
abline(h = 0, col = "red", lty = 2)

# Create a QQ plot of deviance residuals
qqnorm(residuals)
qqline(residuals)


# Check for overdispersion
ratio_deviance_df <- residuals(l_mod1, type = "deviance")^2 / df.residual(l_mod1)
sum(ratio_deviance_df) / df.residual(l_mod1)


```

## GLM modeling and plotting expected outcomes of group * day + sex
```{r echo=TRUE}
#Plot and interpret effects
plotGroup <- effect_plot(l_mod1, pred = group, interval = TRUE, y.label = "Probability of Activated T-cells")
plotSex <- effect_plot(l_mod1, pred = sex, interval = TRUE, y.label = "Probability of Activated T-cells")
plotDay <- effect_plot(l_mod1, pred = day, interval = TRUE, y.label = "Probability of Activated T-cells")

grid.arrange(plotGroup, plotSex, plotDay, ncol = 3)


t_cell_activation
# Calculate the probabilities for all combinations using testMod
combinations <- expand.grid(sex = levels(t_cell_activation$sex),
                            day = levels(t_cell_activation$day),
                            group = levels(t_cell_activation$group))

results <- combinations %>%
  rowwise() %>%
  mutate(probability = predict(l_mod1, newdata = data.frame(sex, day, group), type = "response"))

# Create a heatmap

ggplot(results, aes(x = day, y = group)) +
  geom_tile(aes(fill = probability)) +
  facet_grid(. ~ sex, scales = "free_y") +
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  labs(x = "Day", y = "Group", fill = "Probability of Activated T-cells") +
  theme_minimal()

#plot coefficients
coefficients <- summary(l_mod1)$coefficients[, c("Estimate", "Std. Error")]

# Create a data frame
coefficients_df <- data.frame(
  Variable = rownames(coefficients),
  Estimate = coefficients[, "Estimate"],
  SE = coefficients[, "Std. Error"]
)

# plot it
ggplot(coefficients_df, aes(x = reorder(Variable, Estimate), y = Estimate, ymin = Estimate - 1.96 * SE, ymax = Estimate + 1.96 * SE)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  coord_flip() +
  labs(title = "Coefficients and Confidence Intervals",
       x = "Variable",
       y = "Estimated Coefficient") +
  theme_minimal()

# Create predicted probabilities for all variables
predictor_terms <- c("day", "group")
predictions <- ggpredict(l_mod1, terms = predictor_terms)
plot(predictions)
```


# Calculate the odds ratios and plot 
```{r echo=TRUE}
CI <- exp(confint(l_mod1))
# Extract coefficients
coefficients <- summary(l_mod1)$coef

# Define a significance threshold (e.g., 0.05)
significance_threshold <- 0.05

# Filter significant coefficients
significant_coefficients <- coefficients[coefficients[, 4] < significance_threshold, ]

# Calculate odds ratios
odds_ratios <- exp(significant_coefficients[, 1])

# Add variable names for interpretation
odds_ratios <- data.frame(
  Odds_Ratio = odds_ratios)



odds_ratios <- as.data.frame(odds_ratios) %>% 
    rownames_to_column('Variable')
CI_df <- as.data.frame(CI) %>%
    rownames_to_column('Variable')


odds_ratios <- inner_join(odds_ratios, CI_df, by = "Variable")
odds_ratios$Variable <- gsub("^group", "", odds_ratios$Variable)
odds_ratios <- odds_ratios %>%
  filter(Variable != "(Intercept)")

odds_ratios
```

```{r echo=TRUE}

# Extract the CI values
variables <- odds_ratios[, 1] 
odds_ratio <- odds_ratios[, 2]
lower_ci <- odds_ratios[, 3] 
upper_ci <- odds_ratios[, 4]


odds_data <- data.frame(
  variables = variables,
  odds_ratio = odds_ratio,
  lower_ci = lower_ci,
  upper_ci = upper_ci)

# Reorder the order of "odds_ratios"
odds_data$variables <- factor(odds_data$variables, levels = odds_data$variables[order(odds_data$odds_ratio)])

# Create a plot

ggplot(odds_data, aes(x = odds_ratio, y = variables)) +
  geom_point() +
  geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height = 0) +
  labs(title = "Odds Ratios with 95% Confidence Intervals",
       x = "Odds Ratio",
       y = "Variable") +
    scale_x_continuous(breaks = c(0, 1, 2, 5, 10, 15)) +
   geom_text(aes(label = round(odds_ratio, 2)), vjust = -0.5)
```


# Plot actual CD4+ CD44+ populations for comparison to predicited outcomes
```{r echo=FALSE}
# Plot: Group Comparison of Activated T-cells (Combined Days)
t_cell_activationPLOT %>%
  mutate(group = fct_relevel(group, "Saline", "BCG", "ID93+GLA-SE", "BCG-ID93+GLA-SE")) %>%
  ggplot(aes(x = group, y = proportion_of_activated_tcells, fill = group, color = group)) +
  geom_boxplot(width = 0.5, alpha = 0.5, position = position_dodge(width = 0.75)) +
  geom_point(size = 3, shape = 21, alpha = 0.8, na.rm = TRUE, color = "black",
             position = position_dodge(width = 0.75)) +
    labs(title = "Regulatory Tcells", x = "Group", y = "% activated T-cells (normalized to CD44+)", color = "Vaccine") +
  guides(fill = "none", shape = guide_legend(title = "Vaccine")) +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

# Plot: Group Comparison of Activated T-cells (Facet-wrapped by Day)
t_cell_activationPLOT  %>%
  mutate(group = fct_relevel(group, "Saline", "BCG", "ID93+GLA-SE", "BCG-ID93+GLA-SE")) %>%
  ggplot(aes(x = group, y = proportion_of_activated_tcells, fill = group, color = group)) +
  geom_boxplot(width = 0.5, alpha = 0.5, position = position_dodge(width = 0.75)) +
  geom_point(size = 3, shape = 21, alpha = 0.8, na.rm = TRUE, color = "black",
             position = position_dodge(width = 0.75)) +
    labs(title = "Regulatory Tcells by Day", x = "Group", y = "% activated T-cells (normalized to CD44+)", color = "Vaccine") +
  guides(fill = "none", shape = guide_legend(title = "Vaccine")) +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~ day, scales = "free_y", ncol = 4, strip.position = "top")

t_cell_activationPLOT  %>%
  mutate(group = fct_relevel(group, "Saline", "BCG", "ID93+GLA-SE", "BCG-ID93+GLA-SE")) %>%
  ggplot(aes(x = day, y = proportion_of_activated_tcells, fill = group, color = group)) +
  geom_boxplot(width = 0.5, alpha = 0.5, position = position_dodge(width = 0.75)) +
  geom_point(size = 3, shape = 21, alpha = 0.8, na.rm = TRUE, color = "black",
             position = position_dodge(width = 0.75)) +
    labs(title = "Regulatory Tcells by Day", x = "Group", y = "% activated T-cells (normalized to CD44+)", color = "Vaccine") +
  guides(fill = "none", shape = guide_legend(title = "Vaccine")) +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 


# Plot: Activated T-cells by Sex (Group Comparison with t-tests)
t_cell_activationPLOT  %>%
  mutate(group = fct_relevel(group, "Saline", "BCG", "ID93+GLA-SE", "BCG-ID93+GLA-SE")) %>%
  ggplot(aes(x = sex, y = proportion_of_activated_tcells, fill = sex, color = sex)) +
  geom_boxplot(width = 0.5, alpha = 0.5, position = position_dodge(width = 0.75)) +
  geom_point(size = 3, shape = 21, alpha = 0.8, na.rm = TRUE, color = "black",
             position = position_dodge(width = 0.75)) +
  theme_bw() +
   labs(title = "Regulatory Tcells by Sex", x = "Sex", y = "Regulatory Tcells by Sex and Day") + 
  stat_compare_means(method = "t.test")


# Plot: Activated T-cells by Sex and day (Facet-wrapped by Group with t-test)
t_cell_activationPLOT  %>%
  mutate(group = fct_relevel(group, "Saline", "BCG", "ID93+GLA-SE", "BCG-ID93+GLA-SE")) %>%
  ggplot(aes(x = sex, y = proportion_of_activated_tcells, fill = sex, color = sex)) +
  geom_boxplot(width = 0.5, alpha = 0.5, position = position_dodge(width = 0.75)) +
  geom_point(size = 3, shape = 21, alpha = 0.8, na.rm = TRUE, color = "black",
             position = position_dodge(width = 0.75)) +
  theme_bw() +
  facet_wrap(~ day, ncol = 1) +
  labs(title = "Regulatory Tcells by Sex and Day", x = "Sex", y = "% Activated T-cells (normalized to CD44+)")  + 
  stat_compare_means(method = "t.test", label.y = 5)

```

```{r}
em_means <- emmeans(l_mod1, specs = ~ group * day + sex)

# Perform pairwise comparisons using Tukey's method
pairwise_comparisons <- emmeans::contrast(em_means, method = "pairwise", adjust = "tukey")

pairwise_comparisons <- as.data.frame(pairwise_comparisons)

# View the results of the pairwise comparisons
significant_comparisons <- subset(pairwise_comparisons, p.value < 0.05)
```


EXPLORATORY ANALYSIS in progress
```{r eval=FALSE, fig.height=20, fig.width=10, include=FALSE}
# 
# # Running Stats and Selecting Significant Cell Type Differences for Gated Cells TukeyHSD
# cell_stats <- tidy_Df1 %>%
#    group_by(cell_types) %>%
#   nest() %>%
#   mutate(aov_result = map(data, ~aov(percentage_of_LIVE ~ group, data = .x)),
#          tukey_result = map(aov_result, TukeyHSD),
#          tidy_tukey = map(tukey_result, broom::tidy)) %>%
#   unnest(tidy_tukey, .drop = TRUE) %>%
#   separate(contrast, into = c("contrast1", "contrast2"), sep = "-") %>%
#   dplyr::select(-data, -aov_result, -tukey_result, -term, -null.value) %>%
#   filter(adj.p.value <= 0.05)
# 
# 
# # Join Dataframes Based on Significance and Cell Types
# common_cell_types <- intersect(tidy_Df1$cell_types, cell_stats$cell_types)
# tidy_Df1_filtered <- tidy_Df1 %>%
#   filter(cell_types %in% common_cell_types)
# 
# joined_df <- left_join(tidy_Df1_filtered, cell_stats, by = "cell_types")
# 
# unique(joined_df$group)
```


Saving plots to PDF
```{r eval=FALSE, include=FALSE}
# #save to pdf
# pdf(file = "/Volumes/cvmbs/RSTOR-HenaO_lab/Pablo/SOLOVAX TB/SolovaxTB immunogenicity day 14/Unmixed/FlowJo/CD45_Final_Lung_Plots.pdf",   # The directory you want to save the file in
#    width = 25, # The width of the plot in inches
#    height = 35) # The height of the plot in inches
# plot(CD45_Final_Lung_Plots)
# dev.off()
```

